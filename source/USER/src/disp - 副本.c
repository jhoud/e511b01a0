


#include "disp.h"

#define UP   				GPIO_PIN_4  //LE  锁存输出允许位
#define DN   				GPIO_PIN_5  //LE
#define PIN_SDI     GPIO_PIN_7
#define PIN_CLK     GPIO_PIN_6
//#define POWER       GPIO_PIN_2  //OE

static void SendData(uint16_t value, GPIO_Pin_TypeDef data_place);
static uint8_t floor;

#define ROLL_LINES (6 * 2 -1)

const uint8_t fonts[][PATTERN_SIZE] = {
     {0x00,0x00,0x03,0xC0,0x07,0xE0,0x0C,0x30,     // 0
      0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0C,0x30,
      0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0C,0x30,
      0x0C,0x30,0x07,0xE0,0x03,0xC0,0x00,0x00},	  
	 {0x00,0x00,0x01,0x80,0x03,0x80,0x07,0x80,     // 1
      0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,
      0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,
      0x01,0x80,0x07,0xE0,0x07,0xE0,0x00,0x00},	  
	 {0x00,0x00,0x03,0xC0,0x07,0xE0,0x0E,0x30,     // 2
      0x0C,0x30,0x00,0x30,0x00,0x30,0x00,0x70,
      0x00,0xE0,0x01,0xC0,0x03,0x80,0x07,0x00,
      0x0E,0x00,0x0F,0xF0,0x0F,0xF0,0x00,0x00},  
	 {0x00,0x00,0x03,0xC0,0x07,0xE0,0x0E,0x30,     // 3
      0x0C,0x30,0x00,0x70,0x01,0xE0,0x03,0x80,
      0x03,0x80,0x01,0xE0,0x00,0x70,0x0C,0x30,
      0x0E,0x30,0x07,0xE0,0x03,0xC0,0x00,0x00},	  
	 {0x00,0x00,0x00,0x60,0x00,0xF0,0x00,0xF0,     // 4
      0x01,0xB0,0x03,0xB0,0x07,0x30,0x0E,0x30,
      0x1C,0x30,0x18,0x30,0x18,0x30,0x1F,0xF8,
      0x1F,0xF8,0x00,0x30,0x00,0x30,0x00,0x00},  
	 {0x00,0x00,0x0F,0xF0,0x0F,0xF0,0x0C,0x00,     // 5
      0x0C,0x00,0x0C,0x00,0x0F,0xC0,0x0F,0xE0,
      0x00,0x70,0x00,0x30,0x00,0x30,0x0C,0x30,
      0x0E,0x60,0x07,0xE0,0x01,0x80,0x00,0x00},	  
	 {0x00,0x00,0x00,0x60,0x00,0xC0,0x01,0x80,     // 6
      0x03,0x00,0x06,0x00,0x04,0x00,0x0C,0x00,
      0x0F,0xC0,0x0E,0x60,0x0C,0x30,0x0C,0x10,
      0x04,0x30,0x06,0x60,0x03,0xC0,0x00,0x00},	  	  
	 {0x00,0x00,0x0F,0xF0,0x0F,0xF0,0x0C,0x30,     // 7
      0x00,0x30,0x00,0x70,0x00,0x60,0x00,0xC0,
      0x00,0xC0,0x01,0x80,0x03,0x80,0x03,0x00,
      0x03,0x00,0x03,0x00,0x03,0x00,0x00,0x00},	  
	 {0x00,0x00,0x03,0xC0,0x07,0xE0,0x0C,0x30,     // 8
      0x0C,0x30,0x0C,0x30,0x04,0x20,0x03,0xC0,
      0x03,0xC0,0x04,0x20,0x0C,0x30,0x0C,0x30,
      0x0C,0x30,0x07,0xE0,0x03,0xC0,0x00,0x00},  
	 {0x00,0x00,0x03,0xC0,0x07,0xE0,0x0C,0x30,     // 9
      0x0C,0x30,0x0C,0x30,0x0C,0x30,0x07,0xF0,
      0x03,0xF0,0x00,0x30,0x00,0x30,0x0C,0x30,
      0x0E,0x70,0x07,0xE0,0x01,0xC0,0x00,0x00},  
	 {0x00,0x00,0x01,0x80,0x03,0xC0,0x07,0xE0,     // 上
      0x0D,0xB0,0x19,0x98,0x11,0x88,0x01,0x80,
      0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,
      0x01,0x80,0x01,0x80,0x01,0x80,0x00,0x00},  
	 {0x00,0x00,0x01,0x80,0x01,0x80,0x01,0x80,     // 下
      0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,
      0x01,0x80,0x11,0x88,0x19,0x98,0x0D,0xB0,
      0x07,0xE0,0x03,0xC0,0x01,0x80,0x00,0x00},  
	 {0x7f,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,     // all
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0x00,0x00,0x7f,0xfe}  
};

static const GPIO_Pin_TypeDef RowLck_Pin[] = {GPIO_PIN_0, GPIO_PIN_1 ,GPIO_PIN_2 , GPIO_PIN_3 , GPIO_PIN_7 , GPIO_PIN_6 , GPIO_PIN_5 ,  GPIO_PIN_4 ,  GPIO_PIN_0};
static const GPIO_TypeDef* RowLck_Gpio[] = {GPIOB, GPIOB, GPIOB, GPIOB, GPIOB, GPIOB, GPIOB, GPIOB, GPIOD};

/* 亮度, 0=最暗, 9=最亮 */
static uint8_t Brightness = 0;

/* 设置楼层 */
static const uint8_t * p;
void SetFloor(uint8_t index) {
	floor= index;
}

/* 设置亮度, 0=最暗, 9=最亮 */
void SetBrightness(uint8_t value) {
    if(value > 9) {
        Brightness = 9;
    }
    else {
        Brightness = value;
    }
}

/* 显示初始化 */
void DispInit(void) {
		uint8_t i;
		
		//初始化 行 且设初始值为高电平
		for(i= 0; i<9; i++) {
				GPIO_Init(RowLck_Gpio[i], RowLck_Pin[i], GPIO_MODE_OUT_PP_LOW_FAST);
				GPIO_WriteHigh(RowLck_Gpio[i], RowLck_Pin[i]);       //因为三极管 所以是低电平点亮
		}
		//初始化 列
		GPIO_Init(GPIOC, UP | DN | PIN_SDI | PIN_CLK, GPIO_MODE_OUT_PP_LOW_FAST);    //  |power
		GPIO_WriteLow(GPIOC, UP);
		GPIO_WriteLow(GPIOC, DN);
    GPIO_WriteLow(GPIOC, PIN_CLK);
    GPIO_WriteLow(GPIOC, PIN_SDI);
		//GPIO_WriteLow(GPIOC, POWER);   //默认电源打开
    SendData(0, UP);
		SendData(0, DN);
}

/* 字幕显示任务, 0.1ms任务 */
void TaskDisp(void) {
    static uint8_t row;         //  0~6 行  actrow实际显示的行
    static uint8_t scan_n;      //  0~9 扫描次数
    uint16_t font;              //  字符某行数据
    uint8_t i;
		
    if(row>= 9) {
        row= 0;
    }

   if(0== scan_n) {            //亮度
        // 取字模
        font = 0;		
        // 熄灭所有LED, 输出高电平
				for(i=0; i<9; i++) {
					GPIO_WriteHigh(RowLck_Gpio[i], RowLck_Pin[i]);
				}
        // 输出字模
				if(row<= 0) {					
						SendData(0xffff, UP);	
						font = (uint16_t)fonts[floor][row*2+ 16];
						font = font<< 8;
						font|= (uint16_t)fonts[floor][row*2+ 16+ 1];
						SendData(font, DN);				
						GPIO_WriteLow(RowLck_Gpio[row], RowLck_Pin[row]);						
				}
				else if((row> 0) && (row< 8)){
						font = (uint16_t)fonts[floor][row*2- 2];
						font = font<< 8;
						font|= (uint16_t)fonts[floor][row*2- 1];
						SendData(font, UP);	
						font = (uint16_t)fonts[floor][row*2+ 16];
						font = font<< 8;
						font|= (uint16_t)fonts[floor][row*2+ 1+ 16];
						SendData(font, DN);
						GPIO_WriteLow(RowLck_Gpio[row], RowLck_Pin[row]);
				}
				else if(row>= 8){
						font = (uint16_t)fonts[floor][row*2- 2];
						font = font<< 8;
						font|= (uint16_t)fonts[floor][row*2- 1];
						SendData(font, UP);
						SendData(0xffff, DN);
						GPIO_WriteLow(RowLck_Gpio[row], RowLck_Pin[row]);	
				}				
		}

    if(scan_n > Brightness) {  //控制亮度 大于亮度值就熄灭  以保持亮度  实际上是 显示次数用来控制显示亮度
        // 熄灭所有LED, 输出高电平
				for(i=0; i<9; i++) {
					GPIO_WriteHigh(RowLck_Gpio[i], RowLck_Pin[i]);
				}
    }

    if(scan_n >= 10) {
        scan_n = 0;
        row++;          // 下一行
    }
    else {
        scan_n++;
    }
} 

//模拟spi输出
static void SendData(uint16_t value, GPIO_Pin_TypeDef data_place) {
    uint8_t i;
			
		GPIO_WriteLow(GPIOC, data_place);
		GPIO_WriteLow(GPIOC, PIN_CLK);
		for(i=0; i<16; i++) {
				if(UP== data_place) {	
						if(value & 0x0001) {
								GPIO_WriteHigh(GPIOC, PIN_SDI);//因为低电平点亮
						}
						else {
								GPIO_WriteLow(GPIOC, PIN_SDI);
						}
						GPIO_WriteHigh(GPIOC, PIN_CLK);   //数据移位发生在上升沿
						GPIO_WriteLow(GPIOC, PIN_CLK);
						value >>= 1;                      //value左移
				}
				else if(DN== data_place){
						if(value & 0x8000) {
								GPIO_WriteHigh(GPIOC, PIN_SDI);
						}
						else {
								GPIO_WriteLow(GPIOC, PIN_SDI);
						}
						GPIO_WriteHigh(GPIOC, PIN_CLK);   //数据移位发生在上升沿
						GPIO_WriteLow(GPIOC, PIN_CLK);
						value <<= 1;                      //value左移
				}
		}
		GPIO_WriteHigh(GPIOC, data_place);   			//输出锁存打开
		GPIO_WriteLow(GPIOC, data_place);
}


